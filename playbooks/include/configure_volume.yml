---
- name: Debug volume object
  debug:
      var: volume

- name: Get tag data out of the volume blob
  set_fact:
    tags: "{{ volume.tags }}"

- name: Debug tags
  debug:
      var: tags

- name: Set some variables
  set_fact:
    hypervisor_device: "{{ volume.attachment_set.device }}"
    fstype: "{{ tags.fstype | default('xfs') }}"
    mount_point: "{{ tags.FileSystem }}"

- assert:
    that:
      - mount_point != '/'
      - mount_point != '/root'
      - mount_point != '/boot'
      - mount_point != ''

- name: Stat the hypervisor_device
  ansible.builtin.stat:
      path: "{{ hypervisor_device }}"
  register: hyp_dev_stat_result

- name: Debug hyp_dev_stat_result
  debug:
    var: hyp_dev_stat_result

- name: os_device path 1 of 3 - Translate hypervisor_device to os_device on non-AWS provided images. This is NASTY.
  when: not hyp_dev_stat_result.stat.exists
  block:
    - name: Get list of block devices, excluding the root block device
      ansible.builtin.shell: "/bin/lsblk -d -n -p -o NAME | grep -v nvme0n1 | grep -v xvda | grep -v sda"
      register: lsblk_result

    - name: Gather NVME info for each nvme block device. The info of each device has the external hypervisor device name buried in it.
      ansible.builtin.shell: "/sbin/nvme id-ctrl -v {{ nvme_device }}"
      with_items: "{{ lsblk_result.stdout_lines }}"
      loop_control:
        loop_var: nvme_device
      register: nvme_info_result

    - set_fact:
        short_hyp_dev_name: "{{ hypervisor_device | replace('/dev/', '') }}"
        full_hyp_device_name: "{{ hypervisor_device }}"

    - name: Determine which nvme block device belongs to the hypervisor device we're processing
      set_fact:
          nvme_device: >
            {{ nvme_info_item.stdout | regex_search('"(sd.)') }}
      when: nvme_info_item.stdout | regex_search(short_hyp_dev_name)
      with_items: "{{ nvme_info_result.results }}"
      loop_control:
        loop_var: nvme_info_item

    - fail:
      when: true


    # Binary data line will look something like
    # 0000: 73 64 66 20 20 20 20 20 20 20 20 20 20 20 20 20 "sdf............."
    - name: Limit the nvme info to *just* the line with the hypervsior device name
      set_fact:
        filtered_nvme_info_result: > 
          {{ nvme_info_result.stdout | regex_search('\d+:(\d\d )+ "(/dev/)?(sd.)\.+"') }}

    - name: debug filtered_nvme_info_result
      debug:
          var: filtered_nvme_info_result

    - name: Extract the hypervisor device name from filtered_nvme_info_result
      set_fact:
        hypervisor_device: "{{ filtered_nvme_info_result[-1] | regex_search('sd.') }}"

    - name: Debug nvme_device
      debug:
        var: nvme_device

    - name: Stat nvme_device
      ansible.builtin.stat:
          path: "{{ nvme_device }}"
      register: nvme_device_stat_result

    - name: Debug nvme_device_stat_result
      debug:
        var: nvme_device_stat_result

    - name: Make sure nvme device exists
      assert:
        that:
          - nvme_device_stat_result.stat.exists

    - name: Debug nvme_info_result
      debug:
        var: nvme_info_result

    - name: Make sure nvme device has the expected hypervisor device name
      # "{{ short_hyp_dev_name }}............."   / "sdh............."
      # "{{ full_hyp_device_name    }}........"   / "/dev/sdh........"
      assert:
        that:
          - >
            '"{{ short_hyp_dev_name }}............."' in nvme_info_result.stdout or
            '"{{ full_hyp_device_name    }}........"' in nvme_info_result.stdout

    - name: Finally, set the os_device name to the nvme_device name
      set_fact:
        os_device: "{{ nvme_device }}"

- name: os_device path 2 of 3  - Translate the hypervisor device name to the OS device name when the hypervisor device is a symlink (which it will be on aws-provided images)
  set_fact:
    os_device: "{{ hyp_dev_stat_result.stat.lnk_source }}"
  when: hyp_dev_stat_result.stat.exists
    and hyp_dev_stat_result.stat.islnk

- name: os_device path 3 of 3  - Use the hypervisor device name directly as the OS device name when the hypervisor device is not a symlink
  set_fact:
    os_device: "{{ hypervisor_device }}"
  when: hyp_dev_stat_result.stat.exists
    and not hyp_dev_stat_result.stat.islnk

- name: Debug os_device name
  debug:
      var: os_device

- name: Stat os_device
  ansible.builtin.stat:
      path: "{{ os_device }}"
  register: os_dev_stat_result

- name: Make sure the os_device exists
  assert:
    that:
      - os_dev_stat_result.stat.exists

- name: Make sure we are not about to mess with root device
  assert:
    that:
      - os_device not in ["/dev/xvda", "/dev/nvme0n1", "/dev/sda", "/dev/sda1"]

- name: Format the filesystem. Note that since this is a secondary volume, we don't actually need to create a partition first.
  command: mkfs.{{ fstype }} -f {{ os_device }}
  register: mkfs_result
  changed_when: '"{{ os_device }} contains a mounted filesystem" not in mkfs_result.stderr'
  failed_when: mkfs_result.stderr != '' and not "{{ os_device }} contains a mounted filesystem" in mkfs_result.stderr

- name: Debug mkfs_result
  debug:
      var: mkfs_result

- name: define uuid_cmd
  set_fact:
    uuid_cmd: "/sbin/blkid {{ os_device }} -o value -s UUID"

- name: debug uuid_cmd
  ansible.builtin.debug:
      var: uuid_cmd

- name: Get UUID of the filesystem
  ansible.builtin.command: "{{ uuid_cmd }}"
  register: uuid_result
  changed_when: False  # This command isn't changing anything, so don't ever report it as changed

- name: debug uuid_result
  ansible.builtin.debug:
    var: uuid_result

- set_fact:
    filesystem_uuid: "{{ uuid_result.stdout_lines[0]|trim() }}"

- debug:
    var: filesystem_uuid

- assert:
    that:
      - (filesystem_uuid | length) == 36

- name: Check if the mount point exists
  ansible.builtin.stat:
    path: "{{ mount_point }}"
  register: mount_point_stat_result

- name: Create the mount point if it doesn't exist
  file:
    path: "{{ mount_point }}"
    state: directory
    mode: 0755
    recurse: True
  when: not mount_point_stat_result.stat.exists

- name: Mount the new filesystem now and create a fstab entry so it will be mounted on boot
  mount:
    path: "{{ mount_point }}"
    src: UUID={{ filesystem_uuid }}
    state: mounted
    fstype: "{{ fstype }}"
    opts: defaults,nofail
    dump: 0
